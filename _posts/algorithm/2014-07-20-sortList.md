---
layout: post
title: 【Sorting】【Linked List】Sort List
category: algorithm
description: Sort a linked list in O(n log n) time using constant space complexity. 
---
[Sort List](https://oj.leetcode.com/problems/sort-list/)
>{{ page.description }}

####思路

这里使用归并排序，需要注意的是要将链表断开，不断最后会得到一个循环链表，然后收获一枚TLE.

####代码

```cpp
ListNode* sortList(ListNode* head){
    if(head == NULL || head->next == NULL)
        return head;
    ListNode* walker = head;
    ListNode* runner = head;
    while(runner->next!=NULL && runner->next->next!=NULL){
        walker = walker->next;
        runner = runner->next->next;
    }
    ListNode* head1 = head;
    ListNode* head2 = walker->next;
    walker->next = NULL;//非常重要，将链表断开，一分为二
    
    head1 = sortList(head1);
    head2 = sortList(head2);
    return mergeTwoLists(head1, head2);
}

ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
    if(l1 == NULL)
        return l2;
    else if(l2 == NULL)
        return l1;
        
    ListNode *ResHead, *ResTail;
    ListNode *l1Head = l1;
    ListNode *l2Head = l2; 
    if(l1Head->val < l2Head->val){
        ResHead = l1Head;
        ResTail = l1Head;
        l1Head = l1Head->next;
    }else{
        ResHead = l2Head;
        ResTail = l2Head;
        l2Head = l2Head->next;
    }
    
    //while(l1Head->next != NULL && l2Head->next != NULL)
    while(l1Head != NULL && l2Head != NULL){
        if(l1Head->val < l2Head->val){
            ResTail->next = l1Head;
            ResTail = l1Head;
            l1Head = l1Head->next;
        }else{
            ResTail->next = l2Head;
            ResTail = l2Head;
            l2Head = l2Head->next;
        }
    }
    if(l1Head != NULL){
        ResTail->next = l1Head;
    }else if(l2Head != NULL){
        ResTail->next = l2Head;
    }
    
    return ResHead;
}
```